---
id: lesson-01-ros2-action-servers
title: "Lesson 1: ROS 2 Action Servers for LLM Commands"
sidebar_position: 1
description: Implement ROS 2 Action Servers to expose robot capabilities, allowing LLMs to trigger and monitor complex, long-running tasks.
---

# Lesson 1: ROS 2 Action Servers for LLM Commands

## Lesson Objectives
- Understand the concept and benefits of ROS 2 Actions for complex robot behaviors.
- Learn to define custom ROS 2 Action interfaces.
- Implement a ROS 2 Action Server that can be called by an LLM-driven task planner.

## Prerequisites
- Completion of Chapter 2 lessons on Language Understanding & Task Planning.
- Solid understanding of ROS 2 nodes, topics, and services.
- Basic Python programming skills.

## Concept Explanation
While ROS 2 Services are suitable for immediate, short-duration tasks, many robot behaviors (e.g., navigating to a distant goal, picking up an object, performing a sequence of manipulations) are long-running and require continuous feedback and the ability to be preempted. ROS 2 Actions are designed for precisely these scenarios. They provide a client-server interaction model with explicit goals, feedback, and results, making them ideal for grounding complex, multi-step plans generated by LLMs into executable robot behaviors.

<h2>Step-by-Step Technical Breakdown</h2>

1.  **Define Custom Action Interface**: Create a `.action` file (e.g., `NavigateTo.action`) in a custom ROS 2 package to specify the goal, feedback, and result structure for a specific robot task.
2.  **Implement Action Server**: Develop a ROS 2 Python node that acts as an Action Server. This server will receive goals from clients (which will be the LLM-driven task planner), execute the robot behavior (e.g., call lower-level navigation functions), provide continuous feedback, and send a final result.
3.  **Integrate with Task Planner**: The LLM-driven task planner node (from Chapter 2) will act as an Action Client, sending goals to this Action Server and monitoring its progress.

<h2>Real-World Analogy</h2>
Think of ordering a custom-made cake. You place the order (goal), get updates during the baking process (feedback), and finally receive the finished cake (result). ROS 2 Actions work similarly for robots; you give a complex command, and the robot keeps you updated until the task is done.

<h2>Hands-On Tasks</h2>
1.  Create a new ROS 2 package (e.g., `robot_action_interfaces`) and define a custom `NavigateTo.action` interface.
    ```
    # NavigateTo.action
    # Goal
    string location_name
    ---
    # Result
    bool success
    string message
    ---
    # Feedback
    float32 distance_to_goal
    string current_status
    ```
2.  Implement a mock `navigate_to_action_server.py` ROS 2 node that starts an `NavigateTo` Action Server. When it receives a goal, it should simulate navigation, publish fake feedback, and eventually send a success/failure result.
3.  (Optional) Create a simple Action Client node to test your server.

<h2>Python + ROS2 Examples</h2>

```python
# In robot_action_interfaces/action/NavigateTo.action
# Goal
string location_name
---
# Result
bool success
string message
---
# Feedback
float32 distance_to_goal
string current_status

# In your ROS 2 package (e.g., robot_actions_pkg/robot_actions_pkg/navigate_to_action_server.py)
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from rclpy.action.server import ServerGoalHandle
import time

# Import the custom action interface
from robot_action_interfaces.action import NavigateTo

class NavigateToActionServer(Node):

    def __init__(self):
        super().__init__('navigate_to_action_server')
        self._action_server = ActionServer(
            self,
            NavigateTo,
            'navigate_to',
            self.execute_callback
        )
        self.get_logger().info('NavigateTo Action Server started.')

    def execute_callback(self, goal_handle: ServerGoalHandle):
        self.get_logger().info(f'Executing goal: {goal_handle.request.location_name}')

        feedback_msg = NavigateTo.Feedback()
        feedback_msg.distance_to_goal = 100.0
        feedback_msg.current_status = 'Starting navigation'

        # Simulate navigation progress
        for i in range(10):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled.')
                return NavigateTo.Result(success=False, message='Navigation canceled')

            feedback_msg.distance_to_goal -= 10.0
            feedback_msg.current_status = f'Navigating to {goal_handle.request.location_name}, {feedback_msg.distance_to_goal:.1f}m remaining.'
            self.get_logger().info(f'Feedback: {feedback_msg.current_status}')
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(1)

        goal_handle.succeed()
        result = NavigateTo.Result()
        result.success = True
        result.message = f'Successfully navigated to {goal_handle.request.location_name}'
        self.get_logger().info(f'Goal succeeded: {result.message}')
        return result

def main(args=None):
    rclpy.init(args=args)
    navigate_to_action_server = NavigateToActionServer()
    rclpy.spin(navigate_to_action_server)
    navigate_to_action_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

<h2>Debugging Tips</h2>
-   **Action Definition**: Ensure your `.action` file is correctly defined and your ROS 2 package builds successfully after adding it.
-   **Client-Server Handshake**: Verify that the Action Client can connect to the server and send goals. Use `ros2 action list` and `ros2 action info <action_name>` to inspect.
-   **Feedback Loop**: Check that feedback messages are being published by the server and received by the client as expected.
-   **Preemption Logic**: Test goal cancellation and preemption to ensure the server gracefully handles interruptions.

<h2>Mini Quiz (4-6 questions)</h2>
1.  What is the primary advantage of using ROS 2 Actions over Services for complex robot tasks?
2.  Name the three main components of a ROS 2 Action interface.
3.  What is the role of `ServerGoalHandle` in a ROS 2 Action Server?
4.  When would an LLM-driven task planner act as an Action Client?
5.  How does a ROS 2 Action Server provide continuous updates about task progress?
